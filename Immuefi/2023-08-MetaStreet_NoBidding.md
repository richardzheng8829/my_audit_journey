# If one of auctions in a liquidation will never end, the whole liquidation will never end too, even though other auctions have generated enough liquidity to restore pool's liquidity.

## Bug Description

Here's the sceanrio for the attack.

1) Alice unknowingly bought stolen NFT in marketplaces.

2) Alice borrowed funds by using multiple NFTs including stolen one as collaterals.

3) The communities are informed about the status NFT which is stolen. Major platforms does not allow to trade it publicly.

4) Alice decides not to repay funds, and liquidation kicks in.

5) Auctions for normal collaterals are already over.

6) Nobody's interested in bidding for stolen one, as it wil be useless.

7) As liquidation will never ends, pool will not recover from bad debt.



If `EnglishAuctionCollateralLiquidator.bid()` is never called, `Pool.claim()`, `Pool._processLiquidation()`, `Pool.onCollateralLiquidated()`, `_liquidity.restore()` will never be called, too.

https://github.com/metastreet-labs/metastreet-contracts-v2/blob/master/contracts/liquidators/EnglishAuctionCollateralLiquidator.sol#L440-L445
```solidity
    function _processLiquidation(Auction memory auction_, bytes calldata liquidationContext) internal {
        ...

        /* Liquidate if all auctions for the liquidation are completed */
        if (liquidation_.auctionCount - 1 == 0) {
            ...
            if (
                Address.isContract(liquidation_.source) &&
                ERC165Checker.supportsInterface(liquidation_.source, type(ICollateralLiquidationReceiver).interfaceId)
            ) ICollateralLiquidationReceiver(liquidation_.source).onCollateralLiquidated(liquidationContext, proceeds);

            /* Delete liquidation since all auctions are completed */
            delete _liquidations[auction_.liquidationHash];

            /* Emit LiquidationEnded */
            emit LiquidationEnded(auction_.liquidationHash, proceeds);
        } else {
            ...
        }
    }
```

https://github.com/metastreet-labs/metastreet-contracts-v2/blob/master/contracts/Pool.sol#L1066-L1080
```solidity
    function onCollateralLiquidated(bytes calldata encodedLoanReceipt, uint256 proceeds) external nonReentrant {
        ...
        for (uint256 i; i < loanReceipt.nodeReceipts.length; i++) {
            /* Restore node */
            uint128 restored = (i == loanReceipt.nodeReceipts.length - 1)
                ? proceedsRemaining
                : uint128(Math.min(loanReceipt.nodeReceipts[i].pending, proceedsRemaining));
            _liquidity.restore(
                loanReceipt.nodeReceipts[i].tick,
                loanReceipt.nodeReceipts[i].used,
                loanReceipt.nodeReceipts[i].pending,
                restored
            );

            /* Update proceeds remaining */
            proceedsRemaining -= restored;
        }
        ...
    }
```

## Impact

Liquidity generated by normal auctions in a liquidation will be used to restore pool's liquidity.

Locking of liquidation funds and loss of shareholder value.

## Risk Breakdown
Difficulty to Exploit: Medium
Weakness: High
CVSS2 Score: 8

## Recommendation
It should return generated liquidity back to the pool whenever a auction is over, rather waiting for whole liquidation to be over.

```solidity
    function _processLiquidation(Auction memory auction_, bytes calldata liquidationContext) internal {
+       if (
+           Address.isContract(liquidation_.source) &&
+           ERC165Checker.supportsInterface(liquidation_.source, type(ICollateralLiquidationReceiver).interfaceId)
+       ) ICollateralLiquidationReceiver(liquidation_.source).onCollateralLiquidated(liquidationContext, auction_.highestBid);

        /* Liquidate if all auctions for the liquidation are completed */
        if (liquidation_.auctionCount - 1 == 0) {
            /* Compute total proceeds */
            uint256 proceeds = liquidation_.proceeds + auction_.highestBid;

            /* Transfer proceeds from this contract to source */
            IERC20(liquidation_.currencyToken).safeTransfer(liquidation_.source, proceeds);

            /* If source is a contract that implements ICollateralLiquidationReceiver, make collateral liquidation callback */
-            if (
-                Address.isContract(liquidation_.source) &&
-                ERC165Checker.supportsInterface(liquidation_.source, type(ICollateralLiquidationReceiver).interfaceId)
-            ) ICollateralLiquidationReceiver(liquidation_.source).onCollateralLiquidated(liquidationContext, proceeds);

            /* Delete liquidation since all auctions are completed */
            delete _liquidations[auction_.liquidationHash];

            /* Emit LiquidationEnded */
            emit LiquidationEnded(auction_.liquidationHash, proceeds);
        } else {
            /* Update liquidation proceeds */
-           _liquidations[auction_.liquidationHash].proceeds += auction_.highestBid;

            /* Update liquidation active auctions */
            _liquidations[auction_.liquidationHash].auctionCount -= 1;
        }
    }
```

## Proof of Concept
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/interfaces/interface.sol";

interface IPoolFactory {
    function create(address poolImpl, bytes calldata params) external returns (address);

    function createProxied(address poolImpl, bytes calldata params) external returns (address);

    function owner() external view returns (address);
    
    function addPoolImplementation(address impl) external;
}

interface IPool {
	function deposit(uint128 tick, uint256 amount, uint256 minShares) external returns (uint256 shares);

	function borrow(
        uint256 principal,
        uint64 duration,
        address collateralToken,
        uint256 collateralTokenId,
        uint256 maxRepayment,
        uint128[] calldata ticks,
        bytes calldata options
    ) external returns (uint256);

	function liquidate(bytes calldata encodedLoanReceipt) external;

    function repay(bytes calldata encodedLoanReceipt) external returns (uint256);

    function redeem(uint128 tick, uint256 shares) external;

    function withdraw(uint128 tick) external returns (uint256, uint256);
}

interface IEnglishAuctionCollateralLiquidator {
	function bid(address collateralToken, uint256 collateralTokenId, uint256 amount) external;

    function claim(
        address collateralToken,
        uint256 collateralTokenId,
        bytes calldata liquidationContext
    ) external;
}

interface IBundleCollateralWrapper{
    function mint(address token, uint256[] calldata tokenIds) external returns (uint256);
}

IPoolFactory	constant factory = IPoolFactory(0x1c91c822F6C5e117A2abe2B33B0E64b850e67095);
address			constant poolImpl = 0x200927A3FDf2A1F67749385230dc7769e00308aA;
IEnglishAuctionCollateralLiquidator constant liquidator = IEnglishAuctionCollateralLiquidator(0xE0194F47040E2424b8a65cB5F7112a5DBE1F93Bf);
IBundleCollateralWrapper wrapper = IBundleCollateralWrapper(0xc4dC9eF8763433aAe26635bc5a09e362605fAd18);
address constant depositor =  0x57D1974a8CA59146D91Dd8C5172110e5a390C048;
address constant bidder =  depositor;
address constant bidder2 =  0x12ED7f6ed0491678764c2b222A58452926E44DB6;
address constant borrower =  0x9773cc2b33C0791D1f35a93f6b895c6Ede1feb54;
address constant coolCats =  0x1A92f7381B9F03921564a437210bB9396471050C;
uint256 constant coolCatsId = 5827;
uint256 constant coolCatsId2 = 5118;

contract MetaStreetTest is Test {

    IPool       pool;

    function setUp() public {
        cheats.createSelectFork("mainnet");

        cheats.label(address(factory), "Factory");
        cheats.label(address(liquidator), "Liquidator");
        cheats.label(address(busd), "BUSD");

        uint64[] memory durations = new uint64[](1);
        uint64[] memory rates = new uint64[](1);

        durations[0] = 1 days;
        rates[0] = 3170979198;

        console.log("New pool created with BUSD...");
		pool = IPool(factory.createProxied(poolImpl, abi.encode(coolCats, busd, durations, rates)));
        cheats.label(address(pool), "Pool");
    }

    function testMetaStreetMultipleNFT() external {
        uint128 tick = 1e26 << 8;
        uint128[] memory ticks = new uint128[](1);
        ticks[0] = tick;

        console.log("Step 1: Depositing...");
        cheats.startPrank(depositor);
        busd.approve(address(pool), type(uint256).max);
		pool.deposit(tick, 5 ether, 0);

        console.log("Step 2: Borrowing with 2 NFTs...");
        cheats.startPrank(borrower);
        IERC721(coolCats).approve(address(wrapper), coolCatsId);
        IERC721(coolCats).approve(address(wrapper), coolCatsId2);

        uint256[] tokenIds = new uint256[](2);
        tokenIds.push(coolCatsId);
        tokenIds.push(coolCatsId2);
        uint256 collateralId = wrapper.mint(coolCats, tokenIds);

        cheats.recordLogs();
		pool.borrow(4 ether, 1 days, wrapper, collateralId, 5 ether, ticks, bytes(""));
        CheatCodes.Log[] memory entries = cheats.getRecordedLogs();
        bytes memory encodedLoanReceipt = abi.decode(entries[entries.length - 1].data, (bytes));

        console.log("Step 3: Liquidating...");
        cheats.warp(block.timestamp + 2 days);
		cheats.startPrank(depositor);
		pool.liquidate(encodedLoanReceipt);

        console.log("Step 3.1: Bidding for 5827...");
        busd.approve(address(liquidator), type(uint256).max);
		liquidator.bid(coolCats, coolCatsId, 6 ether);

        console.log("Step 3.2 Nobody bids for 5118...");
        console.log("Step 3.2 Pool's liquidity will not be recoverd...");
    }
}
```