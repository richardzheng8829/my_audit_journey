# Listing can be sold at extreme price with any bidding. A hacker can sandwich `AuctionV1.stakeListing()` with lower buyout price and place buyout bid to end auction.

## Bug Description

A hacker can frontrun `stakeListing()` tx with extremely low `buyout` param and `isAction` param set as `false`.

Then it can backrun victim tx with `placeBid` tx with buyout price to close auction.

Because of existence check for mapping, victim's tx will revert.

https://etherscan.io/address/0x1E061ac5099620148BD64867997F35e0e148C277?utm_source=immunefi#code
```
    function stakeListing(uint256 listing, uint256 buyout, uint256 startingPrice, uint256 durationInSeconds, bool isAuction) external {
        require(_acceptingListings, "AuctionV1: not accepting listings");
        require(_listings[listing].poster == address(0), "AuctionV1: listing already exists");
        ...
    }
    function placeBid(uint256 listing, uint256 amount, uint256 bidID) external {
        ...
        if (!_listings[listing].isAuction) {
            require (amount >= _listings[listing].buyoutPrice, "AuctionV1: not accepting non-buyout bids");
        }
        ...
```

## Impact
Listing will not be auctioned but sold to hacker at extremely low price.

## Recommendation
Please use EIP-712 signature validation to prevent frontrunning and overridding of auction parameters.

Signature will be generated by sender and submitted by trusted operator.

```
+    function stakeListingWithSignature(address staker, uint256 listing, uint256 buyout, uint256 startingPrice, uint256 durationInSeconds, bool isAuction) external {
+        string
+            memory structType = "stakeListingWithSignature(uint256 listing,uint256 buyout,uint256 startingPrice,uint256 durationInSeconds, bool isAuction,uint64 expiration,uint64 nonce)";
+        bytes32 digest = 
+            _hashTypedDataV4(
+                keccak256(
+                    abi.encode(
+                        keccak256(bytes(structType)),
+                        listing,
+                        buyout,
+                        startingPrice,
+                        durationInSeconds,
+                        isAuction,
+                        expiration,
+                        nonce
+                    )
+                )
+            );
+        address signer = ECDSA.recover(digest, signature);
+        require (signer == staker, "Invalid signature");
+        require(msg.sender == trustedOperator, "Only trusted operator);
        ...
    }
```
